---
title: "Prepare Data for Model Calibration"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{prepare_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 6
)
```


- [Description](#description)
- [Getting ready](#getting-ready)
- [Prepare data](#prepare-data)
  - [Import data](#import-data)
  - [First steps in preparing data](#first-steps-in-preparing-data)
  - [Exploring calibration data](#exploring-calibration-data)
  - [Using a bias file](#using-a-bias-file)  
  - [PCA for variables](#pca-for-variables)
- [Prepare user pre-processed data](#prepare-user-pre-processed-data)
- [Using Custom Data Partitions](#using-custom-data-partitions)
  - [Spatial Partitioning with ENMeval](#spatial-partitioning-with-enmeval)
  - [Spatial Partitioning with flexsdm](#spatial-partitioning-with-flexsdm)
- [Saving a prepared_data object](#saving-a-prepared_data-object)

<hr>

## Description

Before starting the ENM process, data must be formatted in a specific structure required by functions in **kuenm2**. This vignette guides users through the steps necessary to prepare occurrence data and environmental predictors using built-in tools. It covers the use of `prepare_data()` and `prepare_user_data()` to generate standardized objects, which are essential for model calibration. The vignette also demonstrates options for applying PCA, incorporating sampling bias, and saving prepared data for later use.

<br>

## Getting ready

If **kuenm2** has not been installed yet, please do so. See the [Main guide](../index.html) for installation instructions. See the [basic data cleaning guide](basic_data_cleaning.html) for some steps on cleaning data.

Use the following lines of code to load **kuenm2** and any other required packages, and define a working directory (if needed). In general, setting a working directory in R is considered good practice, as it provides better control over where files are read from or saved to. If users are not working within an R project, we recommend setting a working directory, since at least one file will be saved at later stages of this guide.

```{r, results='hide', message=FALSE, warning=FALSE}
# Load packages
library(kuenm2)
library(terra)

# Current directory
getwd()

# Define new directory
#setwd("YOUR/DIRECTORY")  # uncomment this line if setting a new directory
```

<br>

## Prepare data

### Import data

We will use occurrence records provided within the **kuenm2** package. Most example data in the package is derived from [Trindade & Marques (2024)](https://doi.org/10.1111/ddi.13931). The `occ_data` object contains 51 occurrences of *Myrcia hatschbachii*, a tree endemic to Southern Brazil. Although this example data set has three columns (species, x, and y), users' input data only requires two numeric columns with longitude and latitude coordinates.

```{r Import occurrence data}
# Import occurrences
data(occ_data, package = "kuenm2")

# Check data structure
str(occ_data)
```

<br>

As predictor variables, we will use other data included in the package. This data set comprises four bioclimatic variables from  [WorldClim 2.1](https://worldclim.org/data/bioclim.html) at 10 arc-minute resolution, and a categorical variable (SoilType) from [SoilGrids](https://soilgrids.org/) resampled to 10 arc-minutes. All variables have been masked using a polygon that delimits the area for model calibration, which was generated by drawing a minimum convex polygon around the records with a 300 km buffer.

```{r Load variables}
# Import raster layers
var <- rast(system.file("extdata", "Current_variables.tif", package = "kuenm2"))

# Check variables
plot(var)
```

<br>

Visualize occurrences records in geography:

```{r }
# Visualize occurrences on one variable
plot(var[["bio_1"]], main = "Bio 1")

points(occ_data[, c("x", "y")], col = "black")
```

<br>

### First steps in preparing data

The function `prepare_data()` is central to getting data ready for model calibration. It handles several key steps:

* **Defining the algorithm**: Users can choose between `maxnet` or `glm`.
* **Generating background points**: Background points area sampled from raster layers, unless provided by the user. These points serve as a reference to contrast presence records.
* **Principal component analysis (PCA)**: An optional step that can be applied to the set of predictors in PCA.
* **Preparing calibration data**: Presence records and background points are associate with predictor values and put together in a `data.frame` to be used in the ENM.
* **Data partitioning**: The function divides your data to prepare training and testing sets via a cross-validation process. The partitioning methods available includes `kfolds`, `subsample`, and `bootstrap`.
* **Defining grid of model parameters**: This helps setting up combinations of feature classes (FCs), regularization multiplier (RM) values (for Maxnet), and sets of predictor variables. An explanation of the roles of RMs and FCs in Maxent models see [Merow et al. 2013](https://doi.org/10.1111/j.1600-0587.2013.07872.x).

As with any function, we recommend consulting the documentation for more detailed explanations (e.g., `help(prepare_data)`). Now, let's prepare our data for model calibration using `prepare_data()`, using 4 k-folds as the partitioning method:

```{r simple prepare data}
# Prepare data for maxnet model
d <- prepare_data(algorithm = "maxnet",
                  occ = occ_data,
                  x = "x", y = "y",
                  raster_variables = var,
                  species = "Myrcia hatschbachii",
                  categorical_variables = "SoilType", 
                  partition_method = "kfolds", 
                  n_replicates = 4,
                  n_background = 1000,
                  features = c("l", "q", "lq", "lqp"),
                  r_multiplier = c(0.1, 1, 2))
```

<br>

The `prepare_data()` function returns a `prepared_data` object, which is a list containing various essential pieces of information fro model calibration. Below is an example of how the object is printed to summarize its components.

```{r print prepared data}
print(d)
```

<br>

The parts of the `prepared_data` object can be explored in further detail by indexing them as in the following example.

```{r explore some data}
# See first rows of calibration data
head(d$calibration_data)

# See first rows of formula grid
head(d$formula_grid)
```

<br>

By default, `prepare_data()` prepares an object for fitting models using `maxnet`. However, this can be changed to use GLM instead. When using GLM, it is not necessary to set regularization multipliers, as this algorithm does not utilize them.

Let's create an object for fitting models using `glm`, this time using the `subsample` partitioning method, with 10 replicates and 70% of the dataset used for training.

```{r prepare glm}
d_glm <- prepare_data(algorithm = "glm",
                      occ = occ_data,
                      x = "x", y = "y",
                      raster_variables = var,
                      species = "Myrcia hatschbachii",
                      categorical_variables = "SoilType", 
                      partition_method = "subsample", 
                      n_replicates = 10, 
                      train_proportion = 0.7,
                      n_background = 300,
                      features = c("l", "q", "p", "lq", "lqp"),
                      r_multiplier = NULL) #Not necessary with glms
#Print object
d_glm
```

<br>

By default, `prepare_data()` extracts background points from the entire extent of the provided raster variables. If you have a species-specific polygon defining the calibration area, you can use it to mask the raster variables and delimit the calibration area. For example, let's create a 100km buffer around the occurrence records:

```{r create buffer}
#Convert dataframe with occurrences to SpatVector
pts <- vect(occ_data, geom = c(x = "x", y = "y"), crs = "EPSG:4326")
#Create buffer
b <- buffer(x = pts, width = 100000) #Width in meters
#Aggregate buffers
b <- terra::aggregate(b)
#Plot buffer
plot(b)
points(occ_data[, c("x", "y")], col = "black")
```

Now, let's use this new polygon to mask the variables within `prepare_data()`. Let's also increase the number of background points to 1,000:

```{r prepare data with mask}
d_buffer <- prepare_data(algorithm = "maxnet",
                         occ = occ_data,
                         x = "x", y = "y",
                         raster_variables = var,
                         mask = b, #Polygon to mask variables
                         species = "Myrcia hatschbachii",
                         categorical_variables = "SoilType",
                         n_background = 1000, partition_method = "kfolds",
                         features = c("l", "q", "p", "lq", "lqp"),
                         r_multiplier = c(0.1, 1, 2, 3, 5))
```

Note the warning message: **"n_background' >= initial number of points, using all points"**. This occurs because, after masking the variables, the total number of pixels within the buffer is less than the specified n_background (1,000). In such cases, all available points within the calibration area will be used as background points.

In the following examples, we'll use the object `d_maxnet`, which was prepared for the maxnet algorithm without a mask. However, all functions are compatible with objects prepared for GLM as well.

<br>

### Exploring calibration data

Users can visualize the distribution of predictor values for occurrence records, background points, and the entire calibration area using histograms. An example is presented below. See full documentation with `help(explore_calibration_hist)` and `help(plot_explore_calibration)`.

```{r explore histogram}
# Prepare histogram data
calib_hist <- explore_calibration_hist(data = d, raster_variables = var,
                                       include_m = TRUE)

# Plot histograms
plot_explore_calibration(explore_calibration = calib_hist)
```

The gray bars represent values across the entire calibration area. Blue bars show values for the background, while green bars display values at presence points (magnified by a factor of 2 for improved visualization). You can customize both the colors and the magnification factor.

<br>

Additionally, users can explore the geographic distribution of occurrence and background points. See full documentation with `help(explore_calibration_geo)`.

```{r explore spatial}
pbg <- explore_calibration_geo(data = d, raster_variables = var[[1]],
                               plot = TRUE)
```

<br>

Note that, by default, background points are selected randomly within the calibration area. However, users can influence the spatial distribution of background, increasing or decreasing the probability of selection in certain regions, by providing a bias file (as demonstrated in the next section).

<br>

### Using a bias file

A bias file is a `SpatRaster` object that contains values that will influence the selection of background points within the calibration area. This can be particularly useful for mitigating sampling bias, for instance, by incorporating the density of records from a target group (as discussed in [Ponder et al. 2001](https://doi.org/10.1046/j.1523-1739.2001.015003648.x), [Anderson et al. 2003](https://doi.org/10.1046/j.1365-2699.2003.00867.x), and [Barber et al. 2020](https://doi.org/10.1111/ddi.13442)).

The bias file must have the same extent, resolution, and number of cells as your raster variables, unless a mask is supplied. If a mask is used, the extent of the bias file should encompass or be larger than the mask extent.

Let's illustrate this with an example bias file included in the package. This `SpatRaster` has lower values in the center and higher values towards the borders:

```{r import bias file}
# Import a bias file
bias <- rast(system.file("extdata", "bias_file.tif", package = "kuenm2"))

plot(bias)
```

<br>

We will now use this bias file to prepare two new datasets: one where the bias effect is "direct" (higher probability in regions with higher bias values) and another where the effect is "inverse" (higher probability in regions with lower bias values):

```{r bias data, results='hide'}
# Using bias as a direct effect in sampling
d_bias_direct <- prepare_data(algorithm = "maxnet",
                              occ = occ_data,
                              x = "x", y = "y",
                              raster_variables = var,
                              species = "Myrcia hatschbachii",
                              categorical_variables = "SoilType",
                              n_background = 1000, 
                              partition_method = "kfolds",
                              bias_file = bias, bias_effect = "direct",  # bias parameters
                              features = c("l", "q", "p", "lq", "lqp"),
                              r_multiplier = c(0.1, 1, 2, 3, 5))

# Using bias as an indirect effect in sampling
d_bias_inverse <- prepare_data(algorithm = "maxnet",
                               occ = occ_data,
                               x = "x", y = "y",
                               raster_variables = var,
                               species = "Myrcia hatschbachii",
                               categorical_variables = "SoilType",
                               n_background = 1000,
                               partition_method = "kfolds",
                               bias_file = bias, bias_effect = "inverse",   # bias parameters
                               features = c("l", "q", "p", "lq", "lqp"),
                               r_multiplier = c(0.1, 1, 2, 3, 5))

# Compare background points generated randomly versus with bias effects
## Saving original plotting parameters
original_par <- par(no.readonly = TRUE)

## Adjusting plotting grid
par(mfrow = c(2,2))  

## The plots to show sampling bias effects
plot(bias, main = "Bias file")
explore_calibration_geo(d, raster_variables = var[[1]],
                        main = "Random Background")
explore_calibration_geo(d_bias_direct, raster_variables = var[[1]],
                        main = "Direct Bias Effect")
explore_calibration_geo(d_bias_inverse, raster_variables = var[[1]],
                        main = "Inverse Bias Effect")

par(original_par)  # Reset grid
```

Note that when the bias effect is "direct", the majority of the background points are sampled from the borders of the calibration area, corresponding to higher bias values. Conversely, with an "inverse" bias effect, most background points are selected from the center, where bias values are lower.

<br>

### PCA for variables

A common approach in ENM involves summarizing the information from a set of predictor variables into a smaller set of uncorrelated variables using Principal Component Analysis (PCA) (see [Cruz-Cardenaz et al. 2014](https://doi.org/10.7550/rmb.36723) for an example). In **kuenm2** users can perform a PCA internally or use variables that have been externally prepared as PCs.

#### Internal PCA

**kuenm2** can perform all PCA transformations internally, eliminating the need to prepare the new PC variables for each scenario of projection. This is particularly advantageous when projecting model results across multiple time scenarios (e.g., various Global Climate Models for different future periods). By performing PCA internally, you only need to store the raw environmental variables (e.g., `bio_1`, `bio_2`, etc.) on your directory, and the functions will handle the PCA transformation as needed. 

Let's explore how to implement this:

```{r prepare data pca}
# Prepare data for maxnet models using PCA parameters
d_pca <- prepare_data(algorithm = "maxnet",
                      occ = occ_data,
                      x = "x", y = "y",
                      raster_variables = var, 
                      do_pca = TRUE, center = TRUE, scale = TRUE,  # PCA parameters
                      species = "Myrcia hatschbachii",
                      categorical_variables = "SoilType",
                      n_background = 1000,
                      partition_method = "kfolds",
                      features = c("l", "q", "p", "lq", "lqp"),
                      r_multiplier = c(0.1, 1, 2, 3, 5))

print(d_pca)
```

<br> 

The elements calibration data and formula grid have now been generated considering the principal components (PCs). By default, all continuous variables were included in the PCA, while categorical variables (e.g., "SoilType") were excluded. The default settings for the number of PCs selected retain the axes that collectively explain 95% of the total variance, and then further filter these, keeping only those axes that individually explain at least 5% of the variance. These parameters can be changed using other arguments in the function `prepare_data`

```{r explore hist}
# Check calibration data
head(d_pca$calibration_data)

# Check formula grid
head(d_pca$formula_grid)

# Explore variables distribution
calib_hist_pca <- explore_calibration_hist(data = d_pca, raster_variables = var,
                                           include_m = TRUE, breaks = 7)

plot_explore_calibration(explore_calibration = calib_hist_pca)
```

As the PCA was performed internally, the `prepared_data` object contains all the necessary information to transform the raw environmental variables into the required PCs **This means that when predicting or projecting models, users should provide raw raster variables**, and the PCs will be obtained internally in the function.

<br>

#### External PCA

Alternatively, users can perform a PCA with their data by using the `perform_pca()` function, or one of their preference. See full documentation with `help(perform_pca)`. Se an example with `perform_pca()` below:

```{r do PCA}
pca_var <- perform_pca(raster_variables = var, exclude_from_pca = "SoilType",
                       center = TRUE, scale = TRUE)

# Plot
plot(pca_var$env)
```

<br>

Now, let's use the PCs generated by `perform_pca()` to prepare the data:

```{r prepare data pca external}
# Prepare data for maxnet model using PCA variables
d_pca_extern <- prepare_data(algorithm = "maxnet",
                             occ = occ_data,
                             x = "x", y = "y",
                             raster_variables = pca_var$env,  # Output of perform_pca()
                             do_pca = FALSE,  # Set to FALSE because variables are PCs
                             species = "Myrcia hatschbachii",
                             categorical_variables = "SoilType", 
                             n_background = 1000, 
                             partition_method = "kfolds",
                             features = c("l", "q", "p", "lq", "lqp"),
                             r_multiplier = c(0.1, 1, 2, 3, 5))

print(d_pca_extern)
```

<br>

Note that since PCA was performed  externally, `do_pca = FALSE`  is set within the `prepare_data` function. This is crucial because setting it to `TRUE` would incorrectly apply PCA to variables that are *already* PCs. Consequently, the `prepared_data` object in this scenario does not store any PCA-related information. This means that when users predict or project models, they must **must provide the PCs** instead of the raw raster variables.

```{r check prepared pca externally}
# Check calibration data
head(d_pca_extern$calibration_data)

# Check formula grid
head(d_pca_extern$formula_grid)
```

<br>

## Prepare user pre-processed data

If users already have data that has been prepared for calibration, they can use the `prepare_user_data()` function to create the object required for model calibration. User-prepared calibration data must be a `data.frame` that includes a column indicating **presence (1)** and **background (0)** records, along with columns with values for each of your **variables**. The package includes an example of such a `data.frame` for reference. See an example of its use below:

```{r import user data}
data("user_data", package = "kuenm2")

head(user_data)
```

<br> 

The `prepare_user_data()` function operates similarly to `prepare_data()`, but with a key difference: instead of requiring a `data.frame` of occurrence coordinates and a `SpatRaster` of predictor variables, it takes your already prepared user `data.frame` (see below). See full documentation with `help(prepare_user_data)`.

```{r prepare user data}
# Prepare data for maxnet model
data_user <- prepare_user_data(algorithm = "maxnet",
                               user_data = user_data,  # user-prepared data.frame
                               pr_bg = "pr_bg",
                               species = "Myrcia hatschbachii",
                               categorical_variables = "SoilType",
                               partition_method = "bootstrap",
                               features = c("l", "q", "p", "lq", "lqp"),
                               r_multiplier = c(0.1, 1, 2, 3, 5))

data_user 
```

This function also allows you to provide a list of index identifying test points for cross-validation to be used during model calibration. If `user_folds` is NULL, the function will automatically partition the data according to the specified `partition_method`, `n_replicates`, and `train_proportion`.

# Using Custom Data Partitions

The functions `prepare_data()` and `prepare_user_data()` in the `kuenm2` package include four built-in methods for randomly partitioning data:

- **"kfolds"**: Splits the dataset into *K* subsets (folds) of approximately equal size. In each replicate, one fold is used as the test set, while the remaining folds are combined to form the training set.

- **"bootstrap"**: Creates the training dataset by sampling observations from the original dataset *with replacement* (i.e., the same observation can be selected multiple times). The test set consists of the observations that were not selected in that specific replicate.

- **"subsample"**: Similar to bootstrap, but the training set is created by sampling *without replacement* (i.e., each observation is selected at most once). The test set includes the observations not selected for training.

Other methods for data partitioning are also available, including those based on spatial rules ([Radosavljevic and Anderson, 2014](https://onlinelibrary.wiley.com/doi/pdf/10.1111/jbi.12227)). Although `kuenm2` does not currently implement spatial partitioning techniques, it is possible to apply them using other R packages and then incorporate the resulting partitions into the `prepared_data` object for model calibration within the `kuenm2` framework.

The [ENMeval](https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html#partition) and [flexsdm](https://sjevelazco.github.io/flexsdm/articles/v01_pre_modeling.html#data-partitioning) R packages offers some options. Below, we provide examples on how to split the data using this packages and include this partition into the `prepared_data` object to run with `kuenm2`.

## Spatial Partitioning with ENMeval

The ENMeval package ([Kass et al. 2021](https://besjournals.onlinelibrary.wiley.com/doi/pdfdirect/10.1111/2041-210X.13628)) provides three spatial partitioning methods:

- **Spatial block**: Divides occurrence data into four groups based on latitude and longitude lines, aiming for groups of roughly equal size.

- **Checkerboard 1 (basic)**: Generates a checkerboard grid over the study area and assigns points to groups based on their location in the grid.

- **Checkerboard 2 (hierarchical)**: Aggregates the input raster at two hierarchical spatial scales using specified aggregation factors. Points are then grouped based on their position in the resulting hierarchical checkerboard.


As an example, let's use the **spatial block** method to partition our dataset. For this example, we will use the object `d`, which corresponds to the `prepared_data` created in previous steps.

```{r import enmeval_block, echo=FALSE}
data(enmeval_block, package = "kuenm2")
```

```{r spatial block enmeval, eval=FALSE}
# Install ENMeval if not already installed
if(!require("ENMeval")){
  install.packages("ENMeval")
}

# Extract calibration data from the prepared_data object and separate presence and background records
calib_occ <- d$calibration_data[d$calibration_data$pr_bg == 1,] #Presences
calib_bg <- d$calibration_data[d$calibration_data$pr_bg == 0,] #Background

# Apply spatial block partitioning using ENMeval
enmeval_block <- get.block(occs = calib_occ, bg = calib_bg)

# Inspect the structure of the output
str(enmeval_block)
#> List of 2
#>  $ occs.grp: num [1:51] 2 1 1 3 1 4 1 1 3 3 ...
#>   $ bg.grp  : num [1:957] 3 3 3 3 3 3 3 1 3 1 ...
```

Note that the output of `get.block()` is a list with two elements: `occs.grp` and `bg.grp`. The `occs.grp` vector has the same length as the number of occurrence records, and `bg.grp` has the same length as the background points. Both vectors contain numeric values from 1 to 4, indicating the spatial group to which each point belongs. For example, an occurrence labeled with `1` belongs to the first spatial block, `2` to the second block, and so on.

In contrast, `kuenm2` stores partitioned data in a different format: it expects a **list of vectors**, where each element corresponds to a replicate and contains the **indices of the test points** for that replicate.


```{r index part kuenm2}
str(d$part_data)
```

We can convert the spatial group information stored in `enmeval_block` into a format compatible with `kuenm2`:

```{r transform enmeval_block}
# Identify unique spatial blocks
id_blocks <- sort(unique(unlist(enmeval_block)))

# Create a list of test indices for each spatial block
new_part_data <- lapply(id_blocks, function(i) {
  # Indices of occurrence records in group i
  rep_i_presence <- which(enmeval_block$occs.grp == i)
  
  # Indices of background records in group i
  rep_i_bg <- which(enmeval_block$bg.grp == i)
  
  # Combine presence and background indices for the test set
  c(rep_i_presence, rep_i_bg)
})

# Assign names to each replicate
names(new_part_data) <- paste0("Rep_", id_blocks)

# Inspect the structure of the new partitioned data
str(new_part_data)
```

We now have a list containing four vectors, each storing the indices of test data defined using the `get.block()` function from the `ENMeval` package. The final step is to replace the original `part_data` in the `prepared_data` object with `new_part_data`. We should also update the partitioning method to reflect this change.

```{r replace part_data}
# Replace the original partition data with the new spatial blocks
d$part_data <- new_part_data

# Update the partitioning method to reflect the new approach
d$partition_method <- "Spatial block (ENMeval)"  # You can use any descriptive name

# Print the updated prepared_data object
print(d)
```

Alternatively, if you have already prepared calibration data, you can define custom data partitioning using the `prepare_user_data()` function. For example, we can use the `user_data` dataset included with the package:

```{r spatial block user data, eval=FALSE}
# Extract presence and background points from the user_data object
user_occ <- user_data[user_data$pr_bg == 1, ]  # Presence records
user_bg  <- user_data[user_data$pr_bg == 0, ]  # Background records

# Apply spatial block partitioning using ENMeval
enmeval_block_user <- get.block(occs = user_occ, bg = user_bg)

# Identify unique spatial blocks
id_blocks <- sort(unique(unlist(enmeval_block_user)))

# Create a list of test indices for each spatial block
user_part_data <- lapply(id_blocks, function(i) {
  # Indices of presence points in block i
  rep_i_presence <- which(enmeval_block_user$occs.grp == i)
  # Indices of background points in block i
  rep_i_bg <- which(enmeval_block_user$bg.grp == i)
  # Combine presence and background indices
  c(rep_i_presence, rep_i_bg)
})

# Name each partition replicate
names(user_part_data) <- paste0("Rep_", id_blocks)

# Prepare user data with custom partitions using prepare_user_data()
data_user_block <- prepare_user_data(
  algorithm = "maxnet",
  user_data = user_data,              # User-provided data frame
  pr_bg = "pr_bg",
  species = "Myrcia hatschbachii",
  categorical_variables = "SoilType",
  user_part = user_part_data,         # Custom partition list
  features = c("l", "q", "p", "lq", "lqp"),
  r_multiplier = c(0.1, 1, 2, 3, 5)
)

# Update partition method description
data_user_block$partition_method <- "Spatial block (ENMeval)"  # Descriptive name

# Display the prepared data object
print(data_user_block)
#> prepared_data object summary
#> ============================
#> Species: Myrcia hatschbachii 
#> Number of Records: 527 
#>   - Presence: 51 
#>   - Background: 476 
#> Partition Method: Spatial block (ENMeval) 
#> Continuous Variables:
#>   - bio_1, bio_7, bio_12, bio_15 
#> Categorical Variables:
#>   - SoilType 
#> PCA Information: PCA not performed
#> Weights: No weights provided
#> Calibration Parameters:
#>   - Algorithm: maxnet 
#>   - Number of candidate models: 610 
#>   - Features classes (responses): l, q, p, lq, lqp 
#>   - Regularization multipliers: 0.1, 1, 2, 3, 5 
```

## Spatial Partitioning with flexsdm

The `flexsdm` ([Velazco et al. 2022](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13874)) offers similar spatial partitioning methods. However, it determines the number or size of bands or blocks based on spatial autocorrelation, environmental similarity, and the number of presence and background records within each partition. For more details, please visit the [package website](https://sjevelazco.github.io/flexsdm/articles/v01_pre_modeling.html#data-partitioning).

As an example, we will use the Spatial Block method, which evaluates different raster cell sizes to identify the optimal block configuration for the dataset.

```{r import flexsdm_block, echo=FALSE}
data(flexsdm_block, package = "kuenm2")
```

```{r spatial block flexsdm, eval=FALSE}
# Install flexsdm if not already installed
if (!require("flexsdm")) {
  install.packages("flexsdm")
}

# Combine calibration data with spatial coordinates
calib_data <- cbind(d$data_xy, d$calibration_data)

# Split data in test and train using flexsdm
flexsdm_block <- part_sblock(env_layer = var, data = calib_data, 
                             x = "x", y = "y",
                             pr_ab = "pr_bg", min_res_mult = 1,
                             max_res_mult = 500, num_grids = 30, n_part = 4, 
                             prop = 0.5)
#> The following grid cell sizes will be tested:
#> 0.17 | 3.03 | 5.9 | 8.77 | 11.64 | 14.51 | 17.37 | 20.24 | 23.11 | 25.98 | 
#> 28.84 | 31.71 | 34.58 | 37.45 | 40.32 | 43.18 | 46.05 | 48.92 | 51.79 | 
#> 54.66 | 57.52 | 60.39 | 63.26 | 66.13 | 68.99 | 71.86 | 74.73 | 77.6 | 
#> 80.47 | 83.33
#> 
#> Creating basic raster mask...
#> 
#> Searching for the optimal grid size...

# See the structure of the object
str(flexsdm_block$part)
#> Classes ‘tbl_df’, ‘tbl’ and 'data.frame':	1008 obs. of  4 variables:
#>  $ x    : num  -51.3 -50.6 -49.3 -49.8 -50.2 ...
#>  $ y    : num  -29 -27.6 -27.8 -26.9 -28.2 ...
#>  $ pr_ab: num  1 1 1 1 1 1 1 1 1 1 ...
#>  $ .part: int  3 1 3 2 3 3 1 4 4 3 ...
```

The output from `flexsdm` differs from that of `ENMeval`. Instead of returning a list with vectors of spatial group IDs for occurrences and background points separately, `flexsdm` appends the group assignments as a new column within the `part` element of its output.

As with the ENMeval example, we can transform the spatial group information stored in `flexsdm_block` into a format compatible with `kuenm2`:

```{r transform flexsdm_block}
# Identify unique spatial blocks from flexsdm output
id_blocks <- sort(unique(flexsdm_block$part$.part))

# Create a list of test indices for each spatial block
new_part_data_flexsdm <- lapply(id_blocks, function(i) {
  # Indices of occurrences and background points in group i
  which(flexsdm_block$part$.part == i)
})

# Assign names to each partition replicate
names(new_part_data_flexsdm) <- paste0("Rep_", id_blocks)

# Inspect the structure of the new partitioned data
str(new_part_data_flexsdm)

# Replace the partition data in the prepared_data object
d$part_data <- new_part_data_flexsdm

# Update the partition method description
d$partition_method <- "Spatial block (flexsdm)"  # You can choose any descriptive name

# Display the updated prepared_data object
print(d)
```

<br>

# Saving a prepared_data object

The `prepared_data` object is crucial for the next step in the ENM workflow in **kuenm2**, model calibration. As this object is essentially a list, users can save it to a local directory using `saveRDS()`. Saving the object facilitates loading it back into your R session later using `readRDS()`. See an example below:

```{r save data, eval=FALSE}
# Set directory to save (here, in a temporary directory)
dir_to_save <- file.path(tempdir())

# Save the data
saveRDS(d, file.path(dir_to_save, "Data.rds"))

# Import data
d <- readRDS(file.path(dir_to_save, "Data.rds"))
```
